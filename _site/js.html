<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>js</title>
    <link rel="stylesheet" href="./assets/css/main.css">
    <link rel="stylesheet" href="./assets/css/style.css">
<!--    <link rel="stylesheet" href="./assets/css/minimum.css">-->
<!--    <script src="./assets/js/script.js" defer></script>-->

</head>
<body>
  <nav>
  <a href="./">home</a>
  <a href="./html">html</a>
  <a href="./css">css</a>
  <a href="./js">js</a>
  <a href="./programming">programming</a>
  <a href="./ide">ide</a>
  <a href="./sys_admin">sys admin</a>
  <a href="./espirit_de_corps">espirit de corps</a>
  <a href="./polis">πόλις</a>
  <a href="./oikos">οίκος</a>
  <a href="./glossa">γλώσσα</a>
</nav>

  <h1 id="destructuring-assignment">Destructuring Assignment</h1>
<p>Essay Topic: “Select what you need, discard the rest” — compare and contrast the assignment operator ‘=’ to the destructuring assignment expression, with emphasis on the differences between array destructuring and object destructuring</p>

<p>Assignment operations allow programs to remember values through symbols.  Simple assignment operations interact with primitive data types and simple data structures, while more complicated assignment operations interact with objects.  Laconically, <code class="language-plaintext highlighter-rouge">a</code> is 123, and <code class="language-plaintext highlighter-rouge">b</code> is “word”.  This description is brief and is useful when running a calculation, but the brevity does violence in understanding how a program achieves that directness of the symbols <code class="language-plaintext highlighter-rouge">a</code> being 123 and <code class="language-plaintext highlighter-rouge">b</code> being “word”.</p>

<p>When 123 is assigned to the variable <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">a</code> now references the <strong>number</strong> 123.  When “word” is assigned to the variable <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">b</code> now references the <strong>string</strong> “word”.  Both the number and string are <strong>primitive data types,</strong> “primitive” because they are the simplest expression available (not an object, has no methods and no properties) and “data type” because machines have to model binary code into something graspable for humans to work with and relate to.  When <code class="language-plaintext highlighter-rouge">a</code> or <code class="language-plaintext highlighter-rouge">b</code> are called, the expression they reference is evaluated and a vale returned.  Evaluating the expression 123 returns the value 123, evaluating the expression “word” returns the value “word”.  This distinction isn’t particularly worthwhile when the expression only consists of primitive data types, but when the expression becomes larger, stating something more verbose and comprehensive, the distinction becomes useful.  That “something” could be, listed in increasing complexity order, a data structure, a function, or an object.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">123</span>
<span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">word</span><span class="dl">"</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The below code block demonstrates how an expression on the right-hand-side of the assignment operator is first evaluated, a value returned and then assigned to a variable on the left-hand-side of the assignment operator.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">[]</span>
<span class="kd">const</span> <span class="nx">d</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>

<span class="kd">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="p">{}</span>
<span class="kd">const</span> <span class="nx">j</span> <span class="o">=</span> <span class="p">{</span><span class="na">w</span><span class="p">:</span> <span class="dl">"</span><span class="s2">w-descriptor</span><span class="dl">"</span><span class="p">}</span>
<span class="kd">const</span> <span class="nx">k</span> <span class="o">=</span> <span class="p">{</span><span class="na">x</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="k">return</span> <span class="dl">"</span><span class="s2">x-descriptor</span><span class="dl">"</span><span class="p">}}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Following evaluation, calls can be made to the variables.  <code class="language-plaintext highlighter-rouge">c</code> returns an array object, and <code class="language-plaintext highlighter-rouge">d</code> returns an array object which contains a sequence of numbers.  <code class="language-plaintext highlighter-rouge">i</code> returns an object literal; <code class="language-plaintext highlighter-rouge">j</code> returns an object literal which contains a property <code class="language-plaintext highlighter-rouge">w</code>; <code class="language-plaintext highlighter-rouge">j.w</code> returns the string “w-descriptor”; <code class="language-plaintext highlighter-rouge">k</code> returns an object literal which contains a property <code class="language-plaintext highlighter-rouge">x</code>; <code class="language-plaintext highlighter-rouge">k.x</code> returns an anonymous function declaration bound to the <code class="language-plaintext highlighter-rouge">x</code> property; <code class="language-plaintext highlighter-rouge">k.x()</code> returns the string “x-descriptor”.</p>

<p>Put another way, <code class="language-plaintext highlighter-rouge">c</code> is a symbol that represents an array object and <code class="language-plaintext highlighter-rouge">d</code> is a symbol that represents an array object containing a sequence of numbers.  <code class="language-plaintext highlighter-rouge">i</code> is a symbol for an object literal; <code class="language-plaintext highlighter-rouge">j</code> is a symbol for an object literal which contains a <code class="language-plaintext highlighter-rouge">w</code> property; <code class="language-plaintext highlighter-rouge">w</code> is a symbol for the string “w-descriptor”; <code class="language-plaintext highlighter-rouge">k</code> is a symbol for an object literal which contains the <code class="language-plaintext highlighter-rouge">x</code> property; <code class="language-plaintext highlighter-rouge">k.x</code> is a symbol for an anonymous function declaration; <code class="language-plaintext highlighter-rouge">k.x()</code> is a symbol for “x-descriptor”.</p>

<p>So far, the left-hand-side of the equation only consists of one symbol.  But when there are two or more symbols on the left-hand-side, the statement changes from a <em>simple assignment</em> to a <em>destructuring assignment</em>.  A destructuring assignment tries to map values on the right-hand-side of the assignment operator to symbols on the left-hand-side of the assignment operator.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="p">[</span><span class="nx">e</span><span class="p">,</span> <span class="nx">f</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">g</span><span class="p">,</span> <span class="nx">h</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In array destructuring assignments, the assignment is based on the number of elements available and their positions.  If the left-hand-side contains the same number of elements as the right-hand-side, then all left-hand-side symbols will return a value: <code class="language-plaintext highlighter-rouge">e</code> returns 7 and <code class="language-plaintext highlighter-rouge">f</code> returns 8.  Whereas if the left-hand-side contains a fewer number of elements than the right-hand-side, then only the first elements in the left-hand-side will be assigned a value, the latter elements will be assigned ‘undefined’, so <code class="language-plaintext highlighter-rouge">g</code> returns 9, and <code class="language-plaintext highlighter-rouge">h</code> returns ‘undefined’.  In the example of <code class="language-plaintext highlighter-rouge">const [e, f]</code>, if <code class="language-plaintext highlighter-rouge">[7, 8]</code> were represented by a symbol <code class="language-plaintext highlighter-rouge">gg</code> then the values can still be distributed.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">gg</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">e</span><span class="p">,</span> <span class="nx">f</span><span class="p">]</span> <span class="o">=</span> <span class="nx">gg</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Array destructuring can be expressed in these terms: <code class="language-plaintext highlighter-rouge">const [a_0, a_1, a_n] = [b_0, b_1, b_n]</code>, where <code class="language-plaintext highlighter-rouge">a</code> is a symbol, <code class="language-plaintext highlighter-rouge">b</code> is a value, and the numbers <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">n</code> represent the positions of related symbols and values.</p>

<p>In object destructuring assignments, instead of assignment based on position, assignment is based on shared symbols. The <code class="language-plaintext highlighter-rouge">l</code> symbol will return a function; the <code class="language-plaintext highlighter-rouge">l()</code> symbol will return “l-descriptor”; <code class="language-plaintext highlighter-rouge">m</code> will return ‘undefined’; <code class="language-plaintext highlighter-rouge">m()</code> will return a TypeError as ‘undefined’ is not a function and cannot be invoked; <code class="language-plaintext highlighter-rouge">r</code>, and what it represents, is discarded.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="p">{</span><span class="nx">l</span><span class="p">,</span> <span class="nx">m</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="na">l</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="dl">"</span><span class="s2">l-descriptor</span><span class="dl">"</span><span class="p">},</span> <span class="na">r</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="dl">"</span><span class="s2">r-descriptor</span><span class="dl">"</span><span class="p">}}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The use case of object destructuring becomes relevant during factory functions when they return object literals.  The returned object literal contain symbols to inner parts of a factory function normally inaccessible to an outer scope by a way of closure.  The object literal returned is then included in another factory function to pass along other symbols:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">Dialogue</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">speak</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{}</span>
    <span class="kd">const</span> <span class="nx">think</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{}</span>
    <span class="kd">const</span> <span class="nx">emote</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{}</span>
    
    <span class="k">return</span> <span class="p">{</span> <span class="nx">speak</span><span class="p">,</span> <span class="nx">think</span><span class="p">,</span> <span class="nx">emote</span> <span class="p">}</span> <span class="c1">// object literal returned when Dialogue is invoked</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">Character</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">speak</span><span class="p">,</span> <span class="nx">think</span><span class="p">,</span> <span class="nx">emote</span> <span class="p">}</span> <span class="o">=</span> <span class="nc">Dialogue</span><span class="p">()</span> <span class="c1">// Dialogue is invoked</span>
    <span class="c1">// speak, think, and emote are available to Character.</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">InnerPersona</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="na">think</span><span class="p">:</span> <span class="nx">reason</span> <span class="p">}</span> <span class="o">=</span> <span class="nc">Dialogue</span><span class="p">()</span>
    <span class="c1">// think is available to InnerPersona through the reason symbol; speak or emote are unavailable</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Dialogue</code> factory function has three named function expressions <code class="language-plaintext highlighter-rouge">speak</code>, <code class="language-plaintext highlighter-rouge">think</code> and <code class="language-plaintext highlighter-rouge">emote</code> from which the <code class="language-plaintext highlighter-rouge">Character</code> factory function can use via destructuring assignment.</p>

<p>Readings</p>
<ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#assignment_operators">assignment operator</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">primitives</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Object">objects</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#object_literals">object literals</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#assigning_to_properties">assignment to properties</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#destructuring">destructuring assignment (primer)</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">destructuring assignment</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#array_destructuring">array destructuring</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#object_destructuring">object destructuring</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors">property accessors</a></li>
</ul>

<h1 id="functions">Functions</h1>
<p>Essay Topic: “Thinking in patterns, forests not trees” — compare and contrast objects produced with <strong>classes</strong> and objects produced by <strong>factory functions</strong>.</p>

<p>Using a high-level programming language, we can logically move from completing operations with primitive operands towards communication between different objects.  This essay attempts to clarify and bridge this gap between these two seemingly unrelated patterns.</p>

<p>Completing simple operations is usually straight-forward, returning a result with low or no side effects: a <strong>simple construct</strong>.  Consider the statement <code class="language-plaintext highlighter-rouge">a + b = c</code> which we would write manually from left to right in sequence. The operation <code class="language-plaintext highlighter-rouge">a + b</code>, (with operands <em>a</em> and <em>b</em>, and the <em>+</em> operator) is executed <code class="language-plaintext highlighter-rouge">=</code>, returns a result <code class="language-plaintext highlighter-rouge">c</code>, with no side effects.  In a program, the execution is done at runtime, so the script would be simply written as <code class="language-plaintext highlighter-rouge">a + b</code>, the program is run which is equivalent to <code class="language-plaintext highlighter-rouge">=</code>, and the program returns the result <code class="language-plaintext highlighter-rouge">c</code>.  As implicitly instructed, the program immediately discards the result.</p>

<p>Variables solve this futile expenditure by allowing the program to store the result in memory for the duration that the program is running.  Variable declarations are interesting because they improve upon the simple construct mentioned prior to provide new capacities.  Variable declarations themselves, like <code class="language-plaintext highlighter-rouge">d = c</code>, are operations with operands, operators and a side effect.  The statement <code class="language-plaintext highlighter-rouge">d = c</code> <em>is</em> the operation (and this expression cannot be reduced any further without affecting what the statement states, for <code class="language-plaintext highlighter-rouge">d</code> alone is not an operation, neither is <code class="language-plaintext highlighter-rouge">=</code> alone, etc.)  The assignment <code class="language-plaintext highlighter-rouge">=</code> operator works on the operands <code class="language-plaintext highlighter-rouge">d</code> and <code class="language-plaintext highlighter-rouge">c</code>, where <code class="language-plaintext highlighter-rouge">d</code> is a reference and <code class="language-plaintext highlighter-rouge">c</code> is a value.  (The word ‘reference’ is used here in place of ‘symbol’ since the entire expression is already using three symbols <code class="language-plaintext highlighter-rouge">d</code>, <code class="language-plaintext highlighter-rouge">=</code>, and <code class="language-plaintext highlighter-rouge">c</code>; using ‘symbol’ would confuse rather than clarify.)  Once the assignment is made, calling <code class="language-plaintext highlighter-rouge">d</code> reproduces the value of <code class="language-plaintext highlighter-rouge">c</code>, with what we know of <code class="language-plaintext highlighter-rouge">c</code> already being discarded.</p>

<p>There are now two patterns we know of: the simple operation construct, and variable declarations, which is an extension of the simple operation construct.  Instead of moving towards variables, we can extend the simple operation construct towards a different direction, a <strong>function</strong>.</p>

<p>A function <code class="language-plaintext highlighter-rouge">f(x, y) {...}</code> extends a simple operation by creating a reference to it.  The reference is an enabler of different degrees.  The first advantage conferred, is that the reference defines the operation once, allowing the reference to be called or invoked <code class="language-plaintext highlighter-rouge">n</code> times to run the operation <code class="language-plaintext highlighter-rouge">n</code> times.  The second advantage conferred, is that the reference only knows to operate on the operands <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>, more specifically, a reference to <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> parameters, not the values of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>; the function is agnostic to its input arguments.  The third advantage conferred is that the reference can be stated without being invoked, of which its use case will contribute later to more complex constructs in the form of a callback.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="c1">// function declaration</span>
<span class="c1">// f is a reference to return x + y</span>
<span class="kd">function</span> <span class="nf">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span>

<span class="c1">// function stated</span>
<span class="nx">f</span><span class="p">;</span>

<span class="c1">// function invoked</span>
<span class="nf">f</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h1 id="variables">Variables</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">var</code></li>
  <li><code class="language-plaintext highlighter-rouge">let</code></li>
  <li><code class="language-plaintext highlighter-rouge">const</code></li>
  <li><code class="language-plaintext highlighter-rouge">"use strict"</code></li>
</ul>

<p>The use case for a variable can be understood when an expression is evaluated.  Expressions return a result when they are evaluated.  If the result is not stored, it is discarded.  Therefore, variables are used to store the result for later use.</p>

<p>Variables are declared and initialised.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">a</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>The variable <strong>a</strong> is declared but not initialised.  Calling <strong>a</strong> returns <code class="language-plaintext highlighter-rouge">undefined</code>.</li>
  <li>The variable <strong>b</strong> is declared and initialised with a value of 10.  Calling <strong>b</strong> returns <code class="language-plaintext highlighter-rouge">10</code>.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">var</code> should be deprecated as <code class="language-plaintext highlighter-rouge">let</code> and <code class="language-plaintext highlighter-rouge">const</code> supersede its use case.  <code class="language-plaintext highlighter-rouge">var</code> is not block scoped, meaning that it can be accessed outside the block it is declared in.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">if </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// x is 5</span>

<span class="k">if </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span> <span class="c1">//  ReferenceError: y is not defined</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">let</code> is block scoped.  The variable can be declared without being initialised.  The variable is ‘dynamically-typed’ meaning that the data type doesn’t need to be specified upon declaration. <code class="language-plaintext highlighter-rouge">let</code> allows for reassignment.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">a</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nx">c</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// reassignment</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">const</code> is block scoped.  The variable must be declared and initialised as <code class="language-plaintext highlighter-rouge">const</code> does not allow for reassignment.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// SyntaxError: Missing initialiser in const declaration</span>
<span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nx">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// TypeError: Assignment to constant variable</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">const</code> cannot be redeclared but can be mutated.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">arr</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">arr</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="c1">// [1, 2]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">'use strict'</code> prevents variables from being declared in your IDE without the keywords <code class="language-plaintext highlighter-rouge">let</code> and <code class="language-plaintext highlighter-rouge">const</code>.  This means that variables can’t accidentally be declared in the global scope</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">words</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">the quick brown fox</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// IDE complains about the implicit declaration of words</span>
<span class="kd">let</span> <span class="nx">sentence</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">over the lazy dog</span><span class="dl">"</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Readings</p>
<ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#declarations">variable declarations</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">strict mode</a></li>
</ul>

<h1 id="functions-1">Functions</h1>
<p>To define function scope… let <strong>aFunction</strong> exist:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="c1">// global scope "space"</span>

<span class="kd">function</span> <span class="nf">aFunction</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// function body "space" of aFunction</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">aFunction</code>’s function scope is equivalent to the function body “space”.  We may define this scope as <code class="language-plaintext highlighter-rouge">s</code>.</li>
  <li>The scope which <code class="language-plaintext highlighter-rouge">aFunction</code> exists is the global scope “space”.  We may define this scope as <code class="language-plaintext highlighter-rouge">s-1</code>, where <code class="language-plaintext highlighter-rouge">-1</code> means outer or “surfacing” by 1 unit.</li>
  <li><code class="language-plaintext highlighter-rouge">aFunction</code> can access variables in the <code class="language-plaintext highlighter-rouge">s</code> space.</li>
  <li><code class="language-plaintext highlighter-rouge">aFunction</code> can access variables in the <code class="language-plaintext highlighter-rouge">s-1</code> space.</li>
</ul>

<hr />

<p>To define function scope… let <strong>aFunction</strong> and <strong>bFunction</strong> exist:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="c1">// global scope "space"</span>

<span class="kd">function</span> <span class="nf">aFunction</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// function body "space" of aFunction</span>
    <span class="kd">function</span> <span class="nf">bFunction</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// function body "space" of bFunction</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Proposition:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">aFunction</code>’s function scope is equivalent to function body “space” of <code class="language-plaintext highlighter-rouge">aFunction</code>.  We define this scope as <code class="language-plaintext highlighter-rouge">s</code></li>
  <li>In the context of <code class="language-plaintext highlighter-rouge">aFunction</code>, the global scope “space” is <code class="language-plaintext highlighter-rouge">s-1</code>.</li>
  <li>In the context of <code class="language-plaintext highlighter-rouge">aFunction</code>, the function body “space” of <code class="language-plaintext highlighter-rouge">bFunction</code> is <code class="language-plaintext highlighter-rouge">s+1</code>, where <code class="language-plaintext highlighter-rouge">+1</code> means inner or “deeper” by 1 unit.</li>
  <li><code class="language-plaintext highlighter-rouge">aFunction</code> can access variables in the<code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">s-1</code> space.</li>
  <li><code class="language-plaintext highlighter-rouge">aFunction</code> cannot access variables in the <code class="language-plaintext highlighter-rouge">s+1</code> space.</li>
</ul>

<p>Contrast:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">bFunction</code>’s function scope is equivalent to function body “space” of <code class="language-plaintext highlighter-rouge">bFunction</code>.  We may define this scope as <code class="language-plaintext highlighter-rouge">s</code>.</li>
  <li>In the context of <code class="language-plaintext highlighter-rouge">bFunction</code>, <code class="language-plaintext highlighter-rouge">aFunction</code>’s scope is <code class="language-plaintext highlighter-rouge">s-1</code>.</li>
  <li>In the context of <code class="language-plaintext highlighter-rouge">bFunction</code>, the global scope is <code class="language-plaintext highlighter-rouge">s-1 -1</code>, or <code class="language-plaintext highlighter-rouge">s-2</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">bFunction</code> can access variables in the <code class="language-plaintext highlighter-rouge">s-1</code> and <code class="language-plaintext highlighter-rouge">s-2</code> space.</li>
</ul>

<p>Terms:</p>
<ul>
  <li>In the context of a function’s scope being <code class="language-plaintext highlighter-rouge">s</code>, the function may access variables in the <code class="language-plaintext highlighter-rouge">s</code> or <code class="language-plaintext highlighter-rouge">s-1</code> or <code class="language-plaintext highlighter-rouge">s-n</code> scope, where <code class="language-plaintext highlighter-rouge">n</code> is an integer.</li>
  <li>However, the function cannot access variables in any <code class="language-plaintext highlighter-rouge">s+1</code> or <code class="language-plaintext highlighter-rouge">s+n</code> scopes.</li>
  <li><code class="language-plaintext highlighter-rouge">aFunction</code>’s inability to access variables in the <code class="language-plaintext highlighter-rouge">bFunction</code> scope, while <code class="language-plaintext highlighter-rouge">bFunction</code> is able to access variables in the <code class="language-plaintext highlighter-rouge">aFunction</code> scope is the basis of a closure.</li>
  <li>Note: if variables are named the same in multiple scopes, then the function will first look for the variable at the scope closest to <code class="language-plaintext highlighter-rouge">s</code> before moving to <code class="language-plaintext highlighter-rouge">s-n</code></li>
</ul>

<p>Readings:</p>
<ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#function_scope">function scope</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#nested_functions_and_closures">nested functions and closures</a></li>
</ul>

<h1 id="functions-2">Functions</h1>
<ul>
  <li>define functions either as a function declaration or function expression</li>
  <li>passing different data types as arguments into functions: strings, numbers, arrays, objects, functions</li>
  <li>function expression use case: named function expression (“I’ll keep this one for later”)</li>
  <li>function expression use case: anonymous function (“function on the fly, forever unknown”)</li>
  <li>function expression use case: immediate invocation (“ka-me-ha-meee-HA!”, immediately invoked function expression)</li>
  <li>shorthand function expressions: arrow syntax (“gotta go fast, haha chilli dogs”)</li>
  <li>shorthand arrow function expressions behave differently to long-form function expressions</li>
  <li>callback functions</li>
  <li>conditional function declaration based on if statement and function expression</li>
  <li>methods are functions that belong to an object</li>
  <li>program execution sequence: function definition -&gt; function call -&gt; function execution</li>
  <li>a call must be in the same scope as the function to succeed</li>
  <li>function hoisting, thesis: the call to a function may be evaluated before its function declaration</li>
  <li>function hoisting, contrast: function expressions must always be evaluated first before a call is made</li>
  <li>when a function is called, arguments are passed</li>
  <li>when a function is declared or expressed, parameters are defined</li>
</ul>

<p>Readings:</p>
<ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions">functions (guide)</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions">functions (reference)</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function">function declaration</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function">function expression</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">shorthand function expressions</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Callback_function">callback functions</a></li>
</ul>

<h1 id="understanding-bind">Understanding .bind</h1>
<ul>
  <li>The below code block demonstrates how <code class="language-plaintext highlighter-rouge">this</code> changes inside a constructor function of a <strong>class</strong> and a <strong>callback function</strong>.</li>
  <li>The statement on line 15 will affect how line 20 is parsed.</li>
  <li>Without <code class="language-plaintext highlighter-rouge">.bind(this)</code>, the <code class="language-plaintext highlighter-rouge">this</code> in <code class="language-plaintext highlighter-rouge">#removeBook</code> refers to the event that was triggered when clicking <code class="language-plaintext highlighter-rouge">#button</code>.</li>
  <li>With <code class="language-plaintext highlighter-rouge">.bind(this)</code>, the <code class="language-plaintext highlighter-rouge">this</code> in <code class="language-plaintext highlighter-rouge">#removeBook</code> refers to the <code class="language-plaintext highlighter-rouge">LibraryController</code> instance.
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">LibraryController</span> <span class="p">{</span>
  <span class="err">#</span><span class="nx">library</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="err">#</span><span class="nx">books</span> <span class="o">=</span> <span class="p">[</span>
      <span class="k">new</span> <span class="nc">Book</span><span class="p">(),</span>
      <span class="k">new</span> <span class="nc">Book</span><span class="p">(),</span>
      <span class="k">new</span> <span class="nc">Book</span><span class="p">(),</span>
  <span class="p">]</span>
  <span class="err">#</span><span class="nx">button</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">button</span><span class="dl">'</span><span class="p">)</span>
    
  <span class="nf">constructor</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">book</span> <span class="k">of</span> <span class="err">#</span><span class="nx">books</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">library</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">book</span><span class="p">)</span>
      <span class="p">}</span>
        
      <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">button</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">removeBook</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="k">this</span><span class="p">))</span>
  <span class="p">}</span>
    
  <span class="err">#</span><span class="nf">removeBook</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// logic here to get the index of the book to remove from the #this.library model</span>
      <span class="k">this</span><span class="p">.</span><span class="err">#</span><span class="nx">library</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="c1">// logic here to remove the node object from the GUI display</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

</body>
</html>
